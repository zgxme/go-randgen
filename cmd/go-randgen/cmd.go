package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"strings"
	"time"

	"github.com/pingcap/go-randgen/gendata"
	"github.com/pingcap/go-randgen/grammar"
	"github.com/pingcap/go-randgen/grammar/sql_generator"
	"github.com/spf13/cobra"
)

var zzPath string
var yyPath string

var queries int
var maxRecursive int
var root string

var debug bool
var skipZz bool
var seed int64
var outPath string

// driver name
var dbms string

var rootCmd = &cobra.Command{
	Use:   "go-randgen",
	Short: "QA tool for fuzzy test just like mysql randgen",
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		initCtx()
	},
}

func initCtx() {
	gendata.InitTmpl(dbms)
}

// init command flag
func initCmd() {
	rootCmd.PersistentFlags().StringVarP(&zzPath, "zz", "Z",
		"", "zz file path, go go-randgen have a default zz")
	rootCmd.PersistentFlags().StringVarP(&yyPath, "yy", "Y", "", "yy file path, required")
	rootCmd.PersistentFlags().IntVarP(&queries, "queries", "Q", 100, "random sql num generated by zz, if it is negative(like -1), exec subcommand will generate endless sql")
	rootCmd.PersistentFlags().StringVarP(&root, "root", "R", "query", "root bnf expression to generate sqls")

	rootCmd.PersistentFlags().IntVar(&maxRecursive, "maxrecur", 5,
		"yy expression most recursive number, if you want recursive without limit ,set it <= 0")
	rootCmd.PersistentFlags().BoolVar(&debug, "debug", false,
		"print detail generate path")
	rootCmd.PersistentFlags().BoolVar(&skipZz, "skip-zz", false,
		"skip gen data phase, only use yy to generate random sqls")
	rootCmd.PersistentFlags().Int64Var(&seed, "seed", time.Now().UnixNano(),
		"random number seed, default time.Now().Nanosecond()")
	rootCmd.PersistentFlags().StringVarP(&outPath, "output", "O", "output",
		"sql output file path")

	// driver
	rootCmd.PersistentFlags().StringVarP(&dbms, "dbms", "D", "doris",
		"specify the DBMS driver, defult Doris. Supported: doris, mysql, sqlite3, postgres")
	rootCmd.AddCommand(newExecCmd())
	rootCmd.AddCommand(newGentestCmd())
	rootCmd.AddCommand(newGenDataCmd())
	rootCmd.AddCommand(newGensqlCmd())
	rootCmd.AddCommand(newZzCmd())
	rootCmd.AddCommand(newListenCmd())
}

func main() {
	initCmd()
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(rootCmd.UsageString())
		os.Exit(1)
	}
}

func getDdls() ([]string, gendata.Keyfun) {
	var zzBs []byte
	var err error
	if zzPath != "" {
		log.Printf("load zz from %s\n", zzPath)
		zzBs, err = ioutil.ReadFile(zzPath)
		if err != nil {
			log.Fatalf("load zz fail, %v\n", err)
		}
	} else {
		log.Println("load default zz")
	}

	zz := string(zzBs)

	ddls, keyf, err := gendata.ByZz(zz)
	if err != nil {
		log.Fatalln(err)
	}

	return ddls, keyf
}

func loadYy() string {
	log.Printf("load yy from %s\n", yyPath)
	yyBs, err := ioutil.ReadFile(yyPath)
	if err != nil {
		log.Fatalf("Fatal Error: load yy from %s fail, %v\n", yyPath, err)
	}

	yy := string(yyBs)

	return yy
}

func getRandSqls(keyf gendata.Keyfun) []string {

	randomSqls := make([]string, 0, queries)

	sqlIter := getIter(keyf)

	err := sqlIter.Visit(sql_generator.FixedTimesVisitor(func(_ int, sql string) {
		randomSqls = append(randomSqls, sql)
	}, queries))

	if err != nil {
		log.Fatalf("Fatal Error: %v \n", err)
	}

	return randomSqls
}

func getIter(keyf gendata.Keyfun) sql_generator.SQLIterator {
	yy := loadYy()

	iterator, err := grammar.NewIterWithRander(yy, root, maxRecursive, keyf,
		rand.New(rand.NewSource(seed)), debug)
	if err != nil {
		log.Fatalln("Fatal Error: " + err.Error())
	}
	return iterator
}

func dumpRandSqls(sqls []string) {
	// different SQL escape characters
	/**
	 * MySQL: `
	 * PostgreSQL: "
	 */
	if strings.EqualFold(strings.ToLower(dbms), "postgres") {
		for i, sql := range sqls {
			sqls[i] = strings.ReplaceAll(
				strings.ReplaceAll(sql, "\"", "'"), // strings
				"`", "\"")                          // column names
		}
	}

	path := outPath + ".rand.sql"
	err := ioutil.WriteFile(path,
		[]byte(strings.Join(sqls, ";\n")+";"), os.ModePerm)
	if err != nil {
		log.Printf("write random sql in dist fail, %v\n", err)
	}

	log.Printf("dump random sqls in %s ok\n", path)
}
